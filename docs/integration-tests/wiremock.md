# 🧪 Search Index Stub for Integration Testing

As part of conducting [our integration tests](README.md) our `UseCase` that interacts with Azure Search Index. For tests over HTTP we need to interact **as closely as possible** with our target service — Azure Search, a PaaS offering that provides server-side searching, paging, and filtering.

Unlike services such as [CosmosDB](./cosmosdb-docker-emulator.md), Azure Search does **not offer a local emulator** (e.g. Docker-based). So to achieve HTTP integration at CI-build we need to stub.

---

## Requirements

1) We use the `Azure.Search.Documents` SDK to interact with Azure Search APIs, which **require HTTPS**.
2) We prefer **not to replace services** in `IServiceCollection`, to preserve the integrity of our integration tests.
3) We need the ability to **stub responses based on request parameters**, e.g. `/indexes/{index}/`.

---

### Issue: Stub the Search Index Contract via a Local Stub Server

// TODO we're using WireMock because it fulfils serving traffic on https:// and, a rules based req/res stubbing model at runtime. Are there other options? More static options with hardcoded json or configuration-driven?

#### ✅ Advantages

- Enables **full HTTP-based integration** without modifying DI or application services.
- Allows realistic request/response flows over HTTPS.

#### ❌ Costs

##### Contract Parity between Mock -> AzureSearch

- We must keep our stubbed index contract with Azure Search.
- Azure Search versions its API via query parameters like `?api-version=`, which we must replicate.
- We SHOULD have **system tests post-deployment** to validate against the real service AzureSearch service.

##### Infrastructure Overhead

- Requires generating and trusting a **local HTTPS certificate** in CI.
  - which requires a **Linux CI runner** to manipulate trust store.
  - Certificates generated by `dotnet dev-certs https` are **not issued by a trusted CA**.
  - Azure SDKs (like `Azure.Search.Documents`) use `HttpClient` with **strict TLS validation** and will reject self-signed certs unless the root is explicitly trusted. Self-signed certificates **lack a trust chain**.

    ```text
    System.Security.Authentication.AuthenticationException: The remote certificate is invalid because of errors in the certificate chain: UntrustedRoot
    ```
    From [Microsoft Docs](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-dev-certs):
    > "By default, the newly created certificate is not trusted. To trust the certificate, use the `--trust` option." However, on **Linux**, `--trust` does not integrate with the host trust store.
    Manually generating a cert with `openssl` also fails (so not using `dotnet-dev-certs`) when a request is made to a self-signed certificate through the Azure SDKs.
    ```bash
    openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    -keyout localhost.key -out localhost.crt \
    -config localhost.conf -subj /CN=localhost
    sudo cp localhost.crt /usr/local/share/ca-certificates/localhost.crt
    sudo update-ca-certificates
    ```
- We must maintain fixture code to configure and run the stub server.
##### Option 2: Disabling TLS on SearchClient
- Some approaches suggest replacing `SearchClient` with a replaced SearchClient that disables certificate validation.
- We DO NOT WANT to modifying application services to preserve test fidelity.
---
### Option 3: In-Memory Stubbing
// TODO: Describe pros and cons of using in-memory stubs instead of a full HTTP stub server.
---
## ✅ Recommendation
We chose **Option 1** — a locally hosted stub server — because it allows us to test our application's integration with Azure Search as realistically as possible, without modifying core services.
To support this:
- We generate a **CA-signed certificate** in CI.
- We trust the CA on the Linux runner.
- We configure WireMock.Net to use the signed certificate.
- This setup satisfies both **WireMock.Net's HttpListener requirements** and **Azure SDK's TLS validation**.